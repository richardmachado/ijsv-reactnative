{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar _require = require('fs'),\n    readFileSync = _require.readFileSync;\n\nvar dotenv = require('dotenv');\n\nfunction parseDotenvFile(path) {\n  var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var content;\n\n  try {\n    content = readFileSync(path);\n  } catch (error) {\n    if (verbose) {\n      console.error('react-native-dotenv', error);\n    }\n\n    return {};\n  }\n\n  return dotenv.parse(content);\n}\n\nmodule.exports = function (_ref) {\n  var t = _ref.types;\n  return {\n    name: 'dotenv-import',\n    pre: function pre() {\n      this.opts = _objectSpread({\n        moduleName: '@env',\n        path: '.env',\n        whitelist: null,\n        blacklist: null,\n        safe: false,\n        allowUndefined: true\n      }, this.opts);\n      var babelMode = process.env.APP_ENV || process.env.BABEL_ENV && process.env.BABEL_ENV !== 'undefined' && process.env.BABEL_ENV || process.env.NODE_ENV || 'development';\n\n      if (this.opts.safe) {\n        var parsed = parseDotenvFile(this.opts.path, this.opts.verbose);\n        var modeParsed = parseDotenvFile(this.opts.path + '.' + babelMode);\n        var localParsed = parseDotenvFile(this.opts.path + '.local');\n        this.env = _extends(_extends(parsed, modeParsed), localParsed);\n      } else {\n        dotenv.config({\n          path: this.opts.path + '.local',\n          silent: true\n        });\n        dotenv.config({\n          path: this.opts.path + '.' + babelMode,\n          silent: true\n        });\n        dotenv.config({\n          path: this.opts.path\n        });\n        this.env = process.env;\n      }\n    },\n    visitor: {\n      ImportDeclaration: function ImportDeclaration(path, _ref2) {\n        var opts = _ref2.opts;\n\n        if (path.node.source.value === opts.moduleName) {\n          for (var _iterator = _createForOfIteratorHelperLoose(path.node.specifiers.entries()), _step; !(_step = _iterator()).done;) {\n            var _ref3 = _step.value;\n\n            var _ref4 = _slicedToArray(_ref3, 2);\n\n            var idx = _ref4[0];\n            var specifier = _ref4[1];\n\n            if (specifier.type === 'ImportDefaultSpecifier') {\n              throw path.get('specifiers')[idx].buildCodeFrameError('Default import is not supported');\n            }\n\n            if (specifier.type === 'ImportNamespaceSpecifier') {\n              throw path.get('specifiers')[idx].buildCodeFrameError('Wildcard import is not supported');\n            }\n\n            if (specifier.imported && specifier.local) {\n              var importedId = specifier.imported.name;\n              var localId = specifier.local.name;\n\n              if (Array.isArray(opts.whitelist) && !opts.whitelist.includes(importedId)) {\n                throw path.get('specifiers')[idx].buildCodeFrameError(\"\\\"\" + importedId + \"\\\" was not whitelisted\");\n              }\n\n              if (Array.isArray(opts.blacklist) && opts.blacklist.includes(importedId)) {\n                throw path.get('specifiers')[idx].buildCodeFrameError(\"\\\"\" + importedId + \"\\\" was blacklisted\");\n              }\n\n              if (!opts.allowUndefined && !Object.prototype.hasOwnProperty.call(this.env, importedId)) {\n                throw path.get('specifiers')[idx].buildCodeFrameError(\"\\\"\" + importedId + \"\\\" is not defined in \" + opts.path);\n              }\n\n              var binding = path.scope.getBinding(localId);\n\n              for (var _iterator2 = _createForOfIteratorHelperLoose(binding.referencePaths), _step2; !(_step2 = _iterator2()).done;) {\n                var refPath = _step2.value;\n                refPath.replaceWith(t.valueToNode(this.env[importedId]));\n              }\n            }\n          }\n\n          path.remove();\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["D:/Lambda/PersonalProjects/ijsv-reactnative/node_modules/react-native-dotenv/index.js"],"names":["require","readFileSync","dotenv","parseDotenvFile","path","verbose","content","error","console","parse","module","exports","t","types","name","pre","opts","moduleName","whitelist","blacklist","safe","allowUndefined","babelMode","process","env","APP_ENV","BABEL_ENV","NODE_ENV","parsed","modeParsed","localParsed","config","silent","visitor","ImportDeclaration","node","source","value","specifiers","entries","idx","specifier","type","get","buildCodeFrameError","imported","local","importedId","localId","Array","isArray","includes","Object","prototype","hasOwnProperty","call","binding","scope","getBinding","referencePaths","refPath","replaceWith","valueToNode","remove"],"mappings":"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","sourcesContent":["const {readFileSync} = require('fs')\r\nconst dotenv = require('dotenv')\r\n\r\nfunction parseDotenvFile(path, verbose = false) {\r\n  let content\r\n\r\n  try {\r\n    content = readFileSync(path)\r\n  } catch (error) {\r\n    // The env file does not exist.\r\n    if (verbose) {\r\n      console.error('react-native-dotenv', error)\r\n    }\r\n\r\n    return {}\r\n  }\r\n\r\n  return dotenv.parse(content)\r\n}\r\n\r\nmodule.exports = ({types: t}) => ({\r\n  name: 'dotenv-import',\r\n\r\n  pre() {\r\n    this.opts = {\r\n      moduleName: '@env',\r\n      path: '.env',\r\n      whitelist: null,\r\n      blacklist: null,\r\n      safe: false,\r\n      allowUndefined: true,\r\n      ...this.opts\r\n    }\r\n\r\n    const babelMode = process.env.APP_ENV || (process.env.BABEL_ENV && process.env.BABEL_ENV !== 'undefined' && process.env.BABEL_ENV) || process.env.NODE_ENV || 'development'\r\n    if (this.opts.safe) {\r\n      const parsed = parseDotenvFile(this.opts.path, this.opts.verbose)\r\n      const modeParsed = parseDotenvFile(this.opts.path + '.' + babelMode)\r\n      const localParsed = parseDotenvFile(this.opts.path + '.local')\r\n      this.env = Object.assign(Object.assign(parsed, modeParsed), localParsed)\r\n    } else {\r\n      dotenv.config({\r\n        path: this.opts.path + '.local',\r\n        silent: true\r\n      })\r\n      dotenv.config({\r\n        path: this.opts.path + '.' + babelMode,\r\n        silent: true\r\n      })\r\n      dotenv.config({\r\n        path: this.opts.path\r\n      })\r\n      this.env = process.env\r\n    }\r\n  },\r\n\r\n  visitor: {\r\n    ImportDeclaration(path, {opts}) {\r\n      if (path.node.source.value === opts.moduleName) {\r\n        for (const [idx, specifier] of path.node.specifiers.entries()) {\r\n          if (specifier.type === 'ImportDefaultSpecifier') {\r\n            throw path.get('specifiers')[idx].buildCodeFrameError('Default import is not supported')\r\n          }\r\n\r\n          if (specifier.type === 'ImportNamespaceSpecifier') {\r\n            throw path.get('specifiers')[idx].buildCodeFrameError('Wildcard import is not supported')\r\n          }\r\n\r\n          if (specifier.imported && specifier.local) {\r\n            const importedId = specifier.imported.name\r\n            const localId = specifier.local.name\r\n\r\n            if (Array.isArray(opts.whitelist) && !opts.whitelist.includes(importedId)) {\r\n              throw path.get('specifiers')[idx].buildCodeFrameError(`\"${importedId}\" was not whitelisted`)\r\n            }\r\n\r\n            if (Array.isArray(opts.blacklist) && opts.blacklist.includes(importedId)) {\r\n              throw path.get('specifiers')[idx].buildCodeFrameError(`\"${importedId}\" was blacklisted`)\r\n            }\r\n\r\n            if (!opts.allowUndefined && !Object.prototype.hasOwnProperty.call(this.env, importedId)) {\r\n              throw path.get('specifiers')[idx].buildCodeFrameError(`\"${importedId}\" is not defined in ${opts.path}`)\r\n            }\r\n\r\n            const binding = path.scope.getBinding(localId)\r\n            for (const refPath of binding.referencePaths) {\r\n              refPath.replaceWith(t.valueToNode(this.env[importedId]))\r\n            }\r\n          }\r\n        }\r\n\r\n        path.remove()\r\n      }\r\n    }\r\n  }\r\n})\r\n"]},"metadata":{},"sourceType":"script"}